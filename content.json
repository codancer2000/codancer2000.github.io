{"posts":[{"title":"论文阅读：《NaSh:Guardrails for an LLM-Powered Natural》","text":"Arxiv Paper: 《NaSh: Guardrails for an LLM-Powered NaturalLanguage Shell》 一、概要本文提出了一个问题：由LLM驱动的shell在架构上和传统的shell有什么区别？并给出了在设计LLM驱动的shell上的一些指导规范。 二、Shell工作流2-1 命令行交互命令行交互用来执行一些一次性（one-off）的操作，如列举文件或者执行一些系统命令，该操作可以看作四个步骤的轮回： Develop: 用户编写command Run: 用户运行command Inspection: 观察系统是否受到严重影响 Revert: 如果发现异常，回滚状态 从用户视角，命令行交互有以下挑战： 用户为了执行命令往往需要阅读文档学习一些外部工具的使用并且在遇到一些非常用的命令时需要操作验证 回滚需要用户检测并重新执行一些复杂的操作，且一旦回滚不充分会导致系统状态的不一致。 2.2 脚本脚本往往用来执行一些可复用(reusable)的操作，和命令行交互一样，用户同样需要进行上述四种操作的轮回，除此之外，编写脚本引入了新的挑战：用户需要保障脚本在未来执行的正确性。 2.3 LLM的机遇与挑战随着LLM的诞生和发展，用户可以越过学习的步骤，直接让LLM生成任务对应的command/script。 由于LLM无法保证其生成结果的正确性且用户并不直接参与到命令/脚本逻辑的设计中，这可能反而会加剧用户检查和回滚脚本的难度。比如脚本可能在非当前的工作目录下生成了文件，用户可能在很久后才会察觉。 即使LLMS生成正确的脚本/命令，但是自然语言本身具备的歧义性也会导致错误的执行结果。例如：“请帮我删除/log目录下的所有log文件”，那么歧义点在于/log目录下子目录的log文件是否需要删除呢？.system.log这种隐藏的log文件是否也需要删除呢？ 三、NaSh: 一个自然语言ShellNaSh引入了“代码生成”，“沙箱环境下的逆堆叠文件系统”，“影响总结”和“基于符号执行的测试用例生成”等方式来解决上述挑战。 3.1 代码生成NaSh设计中的核心问题是如何代表用户与系统交互。传统方法（如LLM代理直接执行系统调用、模拟图形界面操作）存在可解释性和可重复性缺陷，主要因为： 调试困难：若LLM对系统调用或点击操作响应错误，用户难以追踪问题根源 非确定性风险：LLM因技术限制可能对相同输入产生不同输出NaSh的创新方案是让LLM根据用户指令生成可分析、可执行的代码，其优势在于： 可分析性：利用程序分析技术帮助用户纠偏 确定性执行：生成的代码可稳定复现，不受LLM非确定性影响 开发友好性：代码可作为脚本复用，或由用户直接修改完善这一设计通过代码作为媒介实现了可解释性、可重复性和用户可控性的平衡。 3.2 沙箱环境为了避免LLM生成的代码的不确定性引入的风险，NaSh通过沙箱环境安全执行LLMs生成的代码，并提供事务型撤销（undo）机制。为了避免对文件系统的影响，NaSh进行了文件系统的隔离，然而传统的Overlay文件系统修改仅在提交后对其他应用可见且不适用于一些特殊文件（/proc），NaSh创新的引入了逆Overlay文件系统，直接修改操作系统文件但是可以回滚到旧版本（缺陷是对磁盘空间要求高）。 3.3 影响分析由于NaSh基于沙箱环境执行，因此可以监控脚本执行后的影响并基于LLM给出总结，该总结可以帮助LLM/用户来更好的判断系统所受到的影响以进行优化下个版本迭代。 总结个人感觉本文提出的一些方案还是偏理想化，不太好落地。","link":"/2025/06/21/Nash-2025-06-21/"},{"title":"从零到一的大模型之旅：一个大语言模型是如何工作的？","text":"What i cannot create, i do not understand 从2022年11月30日OpenAI发布了智能聊天对话应用ChatGPT以来，大模型在两年半的时间内几乎成为了人人尽知的词语。无论是领域前沿的研究人员，还是企业中的工程师，亦或是自媒体的从业人员，都或多或少的在主动使用大模型来提高自己的效率。凭借对知识的”压缩能力”，人们可以快速高效的获得自己想要得到的答案，人们对于知识获取的方式发生了巨大变革。 作为程序员最重要网站之一的Stack Overflow，在大模型诞生后，面临着“Stack overflow is almost dead”的趋势。 正如Richard Feynman所说：“What i cannot create, i do not understand”，了解大模型运行的基础原理总归是有益的，本文将从大模型的基础原理讲起，理清大模型“智能”背后的技术。 一、一切都是概率，预测下一个词一言以蔽之，大模型本质上是一个“单词补全器”，对于输入的一个单词序列，大模型会给出下一个可能的单词整体的概率分布。，不断的重复这个过程，大模型就能够产生出一段“有意义的”文本。如果大模型收到了下面的输入： 1I want to eat __ 他将会输出候选单词列表中每个单词作为答案的概率，比如： 123apple 0.7flower 0.2sky 0.1 大模型会选择概率最高的单词作为答案，此时用户输入的句子就会变为 1I want to eat apple. ChatGPT之所以能够根据用户的问题回答出对应的答案，本质上也是一种补全。一般情况下，基于大模型的聊天应用都会内置一个提前预制好的单词序列前缀，我们称之为System Prompt（系统提示词），这样在单次问答的场景下，大模型的输出本质上是在补全System Prompt和User System Prompt，通过这种补全机制，大模型便可以输出针对用户问题的答案。 二、向量化，确定一个单词的“语义”显然，计算机从诞生到现在只能用来处理“数字”，而我们输入的是各种自然语言，为了能够让计算机理解单词所对应的语义，我们需要建立起一座从单词到数字的桥梁，在深度学习领域中，这个桥梁叫做Embedding（向量化）。 向量化的目的是为每个单词在一个高维空间中寻找到该单词对应的向量。可以这么理解，每个单词拥有若干的特征，这些特征可以唯一的确认一个单词的含义。如果我们能可视化这个高维空间，我们可以看到意思相近的词语对应的向量挨得越近，如cat和dog，因为它们都是家养宠物。我们也可以通过单词向量之间的运算变换得到一些有意思的发现。比如： $ Vec(Germany) - Vec(Italy) + Vec(Hitler) \\approx Vec(Mussolini) $ 在GPT-3模型中，每个单词向量有12288个维度。当模型接收到一串单词序列后，便会对这个单词序列进行Embedding操作，得到大模型“实际”可以被识别的输入：一个$N * M$的矩阵，$N$为单词数目，$M$为词向量的维度。 三、如何确认上下文语境中的单词含义？Attention is All You Need！虽然向量化可以确定每个输入单词的含义，但是在不同的语境下，同样的单词却有着不同的含义，如何准确的获取每个单词在当前语境下”正确”的向量?从某种角度上讲，一旦能解决这个问题，计算机便可以“理解”句子的含义了。 2017年，Google在NIPS发表了一遍标题为《Attention Is All You Need》的论文，这篇论文通过引入了注意力机制成功的解决了在不同上下文环境下确认单词含义的挑战，这也成为了大模型技术发展的重要基石。 假设大模型输入了一段文本： 1There is a blue cat 在上述语境下，cat将不再是原本的cat，而会受到blue这个形容词的影响，那么这种“影响”是否可也被向量化呢？答案是Yes。在注意力机制中，对单词定义了一种查询操作$Query$，该操作可以理解为：“我前面有形容词吗？”或者“我前面有贬义词么”等一些语义上的讯问。 为了实现查询操作，注意力模块训练了一个矩阵$W_{q}$，将其与当前单词的向量进行点积操作即可得到当前单词的一个查询矩阵$Q$。作为$Query$的回应，注意力模块训练了另外一个矩阵$W_{k}$，前面的单词向量和$W_{k}$点积可以得到每个单词的$K$矩阵。将当前单词的$Q$和前面的每个单词的$K$进行点积，即可得到前面每个单词对当前单词的“影响力”。通过softmax方法归一化，就可以得到每个单词影响当前单词的概率。最终，为了将当前单词“校准到”真实含义的向量，注意力引入了第三个矩阵$W_{v}$，前面的每个单词和$W_{v}$矩阵进行点积后便得到了向量$V$。形式化的，注意力机制可以用如下公式计算： $Attention(Q, K, V) = softmax(\\frac{QK^{T}}{\\sqrt{d_k}})V$ 当计算完当前单词与前面每个单词的注意力后，将当前单词的的向量累加上注意力向量即可得到校准后的向量，换句话说，通过atttion模块计算后，单词的向量编码了更为丰富的含义。 上述描述的计算过程被称为“单头注意力机制”，在Google提出的论文中，Transformer架构采用了并行的多头注意力机制，也即对于每个单词并行的运行多次注意力，然后加权平均得到最终的校准后的向量。 四、Transformer！最终我们得到了大模型的基础架构：Transformer 回过头再看Transformer架构就能发现，序列首先被Embedding，然后经过多层的Attention模块不断强化单词语义，需要注意的是，Transformer在训练过程中采用了Masked Multi-Head Attention，这是为了避免在训练的过程中出现根据数据集后面的单词影响前面单词的情况，比如如果数据集是 1I want to eat _ and eggs 在预测空格部分时，应当只考虑I want to eat对空格位置的影响，所以强制将空格后续位置的Attention设置为0以避免这种影响。最终，Transformer输出下一个单词的概率分布，完成了大模型的“智能”过程。","link":"/2025/06/29/Transformer/"},{"title":"静态程序分析的应用&amp;程序的不可判定性","text":"Translated from《Static Program Analysis》by Anders Møller and Michael I. Schwartzbach 静态分析是一种用来自动化回答程序中可能存在的行为的技术，在本文，我们将介绍为什么静态分析是有用的并探讨分析工具的一些基本特性。 静态程序分析的应用静态分析早在上世纪60年代就已经被用于了编译器优化，近些年来，静态分析同样可以在漏洞检查，程序验证和IDE开发环境中展现出强大的作用。接下来我们给出程序行为的一些例子以及静态分析在这些程序行为上的应用。 面向程序优化的分析如果编译器想要优化程序，那么它必须知道程序的一些性质以生成高效率的代码，例如 程序中是否包含死代码，更具体的，方法f在main方法中可达吗？如果不可达，可以降低生成编译后代码的大小。 循环中一些表达式的值是否每次都相同？如果是：这些表达式可以被提到循环外以减少重复的计算 变量x的值是否以来程序的输入？如果不依赖，x可以在编译期间就被计算出来 变量x取值的上限和下限是多少？这个答案可以用来指导编译器为x分配合适的运行时表示 p和q是否指向了内存中不相交的数据结构？这可能可以并行处理 面向程序正确性的分析大部分成功的分析工具被被设计用于检测程序中的错误，在一些如C语言这样的非安全语言中，这些异常可能会导致严重的安全风险，像Java这种更加安全的语言，异常可能会导致程序终止，例如： 是否存在一个输入导致空指针异常，除零异常或者算数溢出？ 所有的变量在其被访问前都初始化了么？ 所有的数组访问都在数组下标范围内么？ 是否存在危险的引用，如引用了已经被释放的空间地址 程序对于所有的输入是否都会中止？ 还有一些程序正确性的属性取决于程序员为程序/库定义的规范，如： 所有的断言都成功了吗 在调用hasNext之前调用next了么？ 对于某些输入，程序是否抛出了ActivityNotFoundException异常？ 针对移动应用，信息流的正确性十分重要，如 非授权用户访问文件系统的输入是否检查了？ 一些敏感信息是否可被公开访问？ 并发的使用以及事件驱动模型给出了关于程序行为的问题： 是否可能存在数据竞争？ 程序是否有可能死锁？ 面向程序开发的分析现代IDE往往集成入了大量的程序分析来帮助开发者高效的debug，重构以及理解代码，这些分析可能要回答下面的问题 第117行的方法被谁调用了？ 变量x的值是否会影响到y? x可能有哪些类型？ 近似的答案为了保证程序正确性，程序员们通常会使用大量的测试来提高程序确保会像他们想的一样执行，但是正如Dijkstra的名言： 程序测试可以展示错误的存在但是不能展示错误的不存在 我们期望了解对于所有的输入，程序有可能会出现哪些行为，并且我们期望这个过程是自动化的。一个程序分析器就是这样一个以其他程序为输入并且判决输入的程序是否具备某个特性的程序。 推理出程序的行为可能是一间极度困难的事情，哪怕是对一些小的程序，如：对于下面的程序，判断是否对于所有的整数n都会终止运行？ 123456while (n &gt; 1) { if (n % 2 == 0) // if n is even, divide it by two n = n / 2; else // if n is odd, multiply by three and add one n = 3 * n + 1;} 在1937年，Collatz推断这个答案是”yes”，截至到2020年，$n$最大已经被验证到了$2 ^ {68}$，但是没人能够证明是否对于所有的输入都能终止。 即使在逻辑上没有分支的程序也有可能很难推理，对于下面的程序，是否存在输入可以使输出为true? 123x, y, z = input()output: x * x * x + y * y * y + z * z * z == 42 这是一个1954年提出的一个open problem，直到2019年答案才被百万小时后的计算发现。 莱斯定理是1953年提出的一个通用结果，该定理表明了所有的有趣的关于程序（由图灵完备语言编写）行为的问题都是不可被判定的，在一些特殊例子下这个定理很容易被证明： 假设存在一个程序分析器可以判定程序中的变量在任意执行中是否都为常量，形式化的: 这个分析器是程序$A$，$A$以程序$T$作为输入，$T$存在一个变量$x$以及某个值$k$，判定当$T$执行时$x$的值是否总是等于$k$。 我们发现可以用这样一个分析器来解决停机问题 1234x = 17; if (TM(j)) { x = 18;} 上面的方法$TM(j)$模拟了第$j$个图灵机在输入为空时的运行，如果$A$真的存在，那么我们便可以判定停机问题，然而这是不可能的。 乍一看，我们好像得到了一个不乐观的结果，但是这个结论并不影响我们可以给出近似的答案。虽然我们无法构建出一个可以正确判定任意程序行为性质的分析器，但是我们可以构建出能给对于大多数程序提供“有用”答案的分析器。尽管理论上的完美程序分析器不存在，但是我们可以不断优化这个近似答案的精度。 近似的答案对于程序漏洞的挖掘非常有用，可以作为程序正确性的一种“弱验证”，例如，对于有指针特性的C语言，编译器不会过多的限制空指针异常的编译报错 123456789101112131415161718int main(int argc, char *argv[]) { if (argc == 42) { char *p,*q; p = NULL; printf(&quot;%s&quot;,p); } q = (char *)malloc(100); p = q; free(q); *p = ’x’; free(p); p = (char *)malloc(100); p = (char *)malloc(100); q = p; strcat(p,q); assert(argc &gt; 87);} 对于上面的程序，标准编译器gcc并不会检测到上面程序的空指针异常，要想测试到空指针异常用例必须覆盖到argc=42。然而，一旦我们有一个回答输出null的近似的答案，我们便可以在不运行程序的情况下提前检测到异常。 理想情况下，我们的近似答案是保守的（或者安全的），也即所有的错误都倾向于同一侧，这取决于我们实际场景中的需要，例如：我们想要近似估计程序的内存使用量，如果我们的估计值不低于实际的值，那么我们的估计就是保守的。保守的估计和程序分析中的Soundness原则关联密切。我们说一个程序分析器是Soundness的当这个程序分析器绝对不会给出错误的答案（但是可能会回答maybe的判断）。 再次考虑那个判定程序中变量是否为常量的问题，如果我们分析结果的目标是为了进行常量优化，那么我们的分析器应当在只有当这个变量真的是常量的时候回答yes，在判断模糊的时候回答maybe。一个方案是我们可以每次都回答maybe，因此我们面临的工程挑战是如何在展现合理的分析性能的同时尽可能的回答yes。 程序正确性的不可判定性回顾停机问题停机问题：给定一个图灵机 $M$ 和输入 $w$，判断 $M$ 在 $w$ 上是否停机。已知：停机问题是 不可判定的（图灵，1936）。 假设存在一个算法 $Correct(P)$ 能判定 任意程序 $P$ 是否正确（即 fail 状态不可达），那么我们可以用它来判定停机问题，导致矛盾。归约过程：给定一个图灵机 $M$ 和输入 $w$，构造一个新程序 $P_{M, w}$​：$P_{M, w}$​ 模拟 $M$ 在 $w$ 上的运行：如果 $M$ 在 $w$ 上停机 → ​ $P_{M, w}$ 进入 accept 状态（不违反正确性）。如果 $M$ 在 $w$ 上不停机 → $P_{M, w}$​ 永远运行（发散，不进入 fail 状态）。额外添加一个 fail 状态，并确保：仅当 $M$ 在 $w$ 上停机时，$P_{M, w}$ 可能进入 fail 状态（例如，在停机后故意进入 fail）。关键观察：如果 $M$ 在 $w$ 上不停机，则 $P_{M, w}$​ 也不会停机（不会进入 fail 状态），此时 $P_{M, w}$​ 是“正确的”（因为 fail 不可达）。如果 $M$ 在 $w$ 上 停机，则 ${P_{M, w}}$ 可以进入 fail 状态，此时 $P_{M, w}$​ 是“不正确的”。利用 $Correct(P_{M, w})$ 判断停机问题：如果 $Correct(P_{M, w})$ 返回 “True”（程序正确）→ $M$ 在 $w$ 上 不停机。如果 $Correct(P_{M, w})$ 返回 “False”（程序不正确）→ $M$ 在 $w$ 上 停机。矛盾：这样我们就用 $Correct$ 解决了停机问题，但停机问题是不可判定的，因此 $Correct$ 不可能存在。结论：程序正确性问题是不可判定的。 参考[1] https://cs.au.dk/~amoeller/spa/spa.pdf","link":"/2025/07/06/sca-01/"}],"tags":[],"categories":[],"pages":[]}