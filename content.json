{"posts":[{"title":"Hello World","text":"Hello hexo! Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2024/10/07/hello-world/"},{"title":"论文阅读：《NaSh:Guardrails for an LLM-Powered Natural》","text":"Arxiv Paper: 《NaSh: Guardrails for an LLM-Powered NaturalLanguage Shell》 一、概要本文提出了一个问题：由LLM驱动的shell在架构上和传统的shell有什么区别？并给出了在设计LLM驱动的shell上的一些指导规范。 二、Shell工作流2-1 命令行交互命令行交互用来执行一些一次性（one-off）的操作，如列举文件或者执行一些系统命令，该操作可以看作四个步骤的轮回： Develop: 用户编写command Run: 用户运行command Inspection: 观察系统是否受到严重影响 Revert: 如果发现异常，回滚状态 从用户视角，命令行交互有以下挑战： 用户为了执行命令往往需要阅读文档学习一些外部工具的使用并且在遇到一些非常用的命令时需要操作验证 回滚需要用户检测并重新执行一些复杂的操作，且一旦回滚不充分会导致系统状态的不一致。 2.2 脚本脚本往往用来执行一些可复用(reusable)的操作，和命令行交互一样，用户同样需要进行上述四种操作的轮回，除此之外，编写脚本引入了新的挑战：用户需要保障脚本在未来执行的正确性。 2.3 LLM的机遇与挑战随着LLM的诞生和发展，用户可以越过学习的步骤，直接让LLM生成任务对应的command/script。 由于LLM无法保证其生成结果的正确性且用户并不直接参与到命令/脚本逻辑的设计中，这可能反而会加剧用户检查和回滚脚本的难度。比如脚本可能在非当前的工作目录下生成了文件，用户可能在很久后才会察觉。 即使LLMS生成正确的脚本/命令，但是自然语言本身具备的歧义性也会导致错误的执行结果。例如：“请帮我删除/log目录下的所有log文件”，那么歧义点在于/log目录下子目录的log文件是否需要删除呢？.system.log这种隐藏的log文件是否也需要删除呢？ 三、NaSh: 一个自然语言ShellNaSh引入了“代码生成”，“沙箱环境下的逆堆叠文件系统”，“影响总结”和“基于符号执行的测试用例生成”等方式来解决上述挑战。 3.1 代码生成NaSh设计中的核心问题是如何代表用户与系统交互。传统方法（如LLM代理直接执行系统调用、模拟图形界面操作）存在可解释性和可重复性缺陷，主要因为： 调试困难：若LLM对系统调用或点击操作响应错误，用户难以追踪问题根源 非确定性风险：LLM因技术限制可能对相同输入产生不同输出NaSh的创新方案是让LLM根据用户指令生成可分析、可执行的代码，其优势在于： 可分析性：利用程序分析技术帮助用户纠偏 确定性执行：生成的代码可稳定复现，不受LLM非确定性影响 开发友好性：代码可作为脚本复用，或由用户直接修改完善这一设计通过代码作为媒介实现了可解释性、可重复性和用户可控性的平衡。 3.2 沙箱环境为了避免LLM生成的代码的不确定性引入的风险，NaSh通过沙箱环境安全执行LLMs生成的代码，并提供事务型撤销（undo）机制。为了避免对文件系统的影响，NaSh进行了文件系统的隔离，然而传统的Overlay文件系统修改仅在提交后对其他应用可见且不适用于一些特殊文件（/proc），NaSh创新的引入了逆Overlay文件系统，直接修改操作系统文件但是可以回滚到旧版本（缺陷是对磁盘空间要求高）。 3.3 影响分析由于NaSh基于沙箱环境执行，因此可以监控脚本执行后的影响并基于LLM给出总结，该总结可以帮助LLM/用户来更好的判断系统所受到的影响以进行优化下个版本迭代。 总结目前感觉本文提出的一些方案还是偏理论，不太好落地，但在解决一些工程问题的时候仍然有一定的参考意义。","link":"/2025/06/21/Nash-2025-06-21/"}],"tags":[],"categories":[],"pages":[]}